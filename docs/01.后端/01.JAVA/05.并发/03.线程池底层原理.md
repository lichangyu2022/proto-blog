---
title: 线程池底层原理
date: 2022-11-01 17:57:27
permalink: /pages/7d973c/
categories:
  - 后端
  - JAVA
  - 并发
tags:
  - 
author: 
  name: Proto
  link: https://github.com/lichangyu2022
---


# 线程池底层原理

## 线程池和线程的关系

线程池是一种池化技术，可以复用线程，将线程放到初始化的工作池中，方便资源统一管理。
能够避免线程的重复创建和销毁，提高性能。

类似于线程池这种有很多，像数据库连接池等等。

## 线程和线程池的五种状态




## 线程池的分类

## 线程池源码分析


```

 public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        int c = ctl.get();
        
        //判断当前线程数是否小于核心线程数
        if (workerCountOf(c) < corePoolSize) {
            //如果小于核心线程数 就创建新的线程  创建成功就return
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        
        //如果前两个条件不符合的话  判断是否是运行状态并且能够加入任务到工作队列中
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            // double check 一下 如果任务再添加到工作队列后状态变成了非运行 就移除任务然后reject
            // 一般出现这种情况是 线程执行到这里线程池 shutdown 了
            if (! isRunning(recheck) && remove(command))
                reject(command);
            // 判断当前线程数是不是为0 ，如果是就新增一个线程
            else if (workerCountOf(recheck) == 0)
                // 创建一个null 的任务是为了保证线程池再running的状态必须要有一个任务再执行
                addWorker(null, false);
        }
        // 如果前面两个都不满足就说明不能加到工作队列里面，那就要创建一个新的线程
        // 创建线程失败就说明线程池进入shutdown状态或者饱和状态 要reject 拒绝策略
        else if (!addWorker(command, false))
            reject(command);
    }

```


```
private boolean addWorker(Runnable firstTask, boolean core) {
        // 用于多重循环跳出   goto写法java中用的不多，具体可以百度
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            // 判断 线程状态为非运行而且非 shutdown状态状态任务为空(注意这里的task == null)，队列非空 不进行创建线程
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                return false;
          
            for (;;) {
                int wc = workerCountOf(c);
                // 判断当前线程数是否大于等于最大值 
                // 或者 当前线程数是否大于 阈值数 就说明线程池饱和了，不在新增 (corePoolSize 或者 maximumPoolSize  看你core传的是true还是false)
                if (wc >= CAPACITY ||
                    wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
                if (compareAndIncrementWorkerCount(c))  cas操作 c自增1 成功就结束循环，注意retry
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)  // 比较状态，比较开始时的状态和现在的状态，不一致就跳出本次循环进行重试
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            // 创建worker对象 就这俩this.firstTask = firstTask  this.thread = getThreadFactory().newThread(this);
            w = new Worker(firstTask);  
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    // 获取下当前线程
                    int rs = runStateOf(ctl.get());

                    // 判断是running状态或者(队列里边的任务)  
                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        //没有start的话就抛异常
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;  //记录下线程数
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);  //撤销操作 线程数-1 移除work
        }
        return workerStarted;
    }

```

```
 private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    {
      
        private static final long serialVersionUID = 6138294804551838833L;

        final Thread thread;
        Runnable firstTask;
        // 监控线程 统计完成的任务数
        volatile long completedTasks;

        Worker(Runnable firstTask) {
            setState(-1);  //禁止中断直到runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }
        
        // Worker 本身就是个Runnable 所以最后start执行的时候 一定会调用run 方法
        public void run() {
            runWorker(this);
        }
    }
```

```
 final void runWorker(Worker w) {
          Thread wt = Thread.currentThread();
          Runnable task = w.firstTask;
          w.firstTask = null;
          w.unlock(); // allow interrupts
          boolean completedAbruptly = true;
          try {
              // task不等于null 或者 从消息队列里面拿到的任务 不等于 null 注意 gettask方法
              while (task != null || (task = getTask()) != null) {
                  w.lock();
                  // 判断线程中断标志interrupted
                  if ((runStateAtLeast(ctl.get(), STOP) ||
                       (Thread.interrupted() &&
                        runStateAtLeast(ctl.get(), STOP))) &&
                      !wt.isInterrupted())
                      wt.interrupt();
                  try {
                      // 任务执行的前置方法 ，可以自定义实现  
                      beforeExecute(wt, task);
                      Throwable thrown = null;
                      try {
                          task.run();
                      } catch (RuntimeException x) {
                          thrown = x; throw x;
                      } catch (Error x) {
                          thrown = x; throw x;
                      } catch (Throwable x) {
                          thrown = x; throw new Error(x);
                      } finally {
                          // 后置方法也是一样的
                          afterExecute(task, thrown);
                      }
                  } finally {
                      // 为空后 while循环中的task 会从队列里面取任务
                      task = null;
                      w.completedTasks++;
                      w.unlock();
                  }
              }
              completedAbruptly = false;
          } finally {
              // 这个比较重要
              processWorkerExit(w, completedAbruptly);
          }
       }
       
```


```
    private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // 当队列中为空或者 线程状态为shutdown时 返回null
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }

            int wc = workerCountOf(c);

            // 线程销毁的标记  核心线程也可以销毁
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

            if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
```

```
    private void processWorkerExit(Worker w, boolean completedAbruptly) {
        if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
            decrementWorkerCount();

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            completedTaskCount += w.completedTasks;
            workers.remove(w);
        } finally {
            mainLock.unlock();
        }

        tryTerminate();

        int c = ctl.get();
        if (runStateLessThan(c, STOP)) {
            if (!completedAbruptly) {
                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
                if (min == 0 && ! workQueue.isEmpty())
                    min = 1;
                if (workerCountOf(c) >= min)
                    return; // replacement not needed
            }
            addWorker(null, false);
        }
    }
```


## 可动态配置的线程池